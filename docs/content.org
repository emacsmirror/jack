#+TITLE: OSTA - Org Static
#+DATE: <2022-02-06 Sun>

* Home page
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /
:END:

I'm the home page.

* About page
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /about/
:END:

I'm the about page.

* 404
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /404/
:END:

I'm the 404 page.

* Why osta?
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /why-osta/
:END:

I wrote ~osta~ to do *tech* blogging.

More precisely to talk about *programs* (not programming).

To me, it involves only three components:
1) chunks of code,
2) links to those chunks of code and,
3) the people (big thank you!!!) who wrote those chunks of code.

So, when I wrote it, I focused on those aspects.

As a result, I left out many org elements:
- I don't do math.  No support for Latex,
- I don't use images.  No support for images.
- etc.

You can find the complete list of the org elements that are not
supported in the commentary section of the file ~osta.el~

* osta-html implementation details
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /osta-html-implementation-details/
:OSTA_DATE: [2022-02-08 Tue]
:END:
** Summary

In this post, we show how ~osta-html~ processes the following *component*

#+BEGIN_SRC emacs-lisp
'(:div/foo.bar
  "A"
  (:p (@ :class "baz") "B" (:hr) "C")
  ("D" "E" "F"))
#+END_SRC

in order to return the following string

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC emacs-lisp
"<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>DEF</div>"
#+END_SRC

that we can use to produce this following html snippet:

#+BEGIN_SRC html
<div id="foo" class="bar">
  A
  <p class="baz">B<hr />C</p>
  DEF
</div>
#+END_SRC

** Description of the program

In this section we call ~input-tree~ the data structure ~osta-html~
receives as input.

For instance, in the form

: (osta-html '(:div.foo (:p "bar-1" (:span "baz") "bar-2")))

the data structure

: '(:div.foo (:p "bar-1" (:span "baz") "bar-2"))

is the ~input-tree~.

With that said, let's describe our program.

While traversing ~input-tree~ ([[https://en.wikipedia.org/wiki/Depth-first_search][DFS]] algorithm), we builds a tree
containing a left part and a right part that represents the html
string to be returned at the end of the traversal.

While the left part of this tree is always a string, the right part can
grow recursively by dividing it into two parts (left and right).

In the following example, we can see the successive states of the
this tree when ~input-tree~ is ~'(:div.foo (:p "bar-1" (:span "baz")
"bar-2"))~:

#+BEGIN_SRC emacs-lisp
(:left ""
 :right "")

(:left "<div class=\"foo\">"
 :right "</div>")

(:left "<div class=\"foo\"><p>"
 :right "</p></div>")

(:left "<div class=\"foo\"><p>bar-1"
 :right "</p></div>")

(:left "<div class=\"foo\"><p>bar-1<span>"
 :right (:left "</span>"
         :right "</p></div>"))

(:left "<div class=\"foo\"><p>bar-1<span>baz"
 :right (:left "</span>"
         :right "</p></div>"))

(:left "<div class=\"foo\"><p>bar-1<span>baz</span>"
 :right "</p></div>")

(:left "<div class=\"foo\"><p>bar-1<span>baz</span>bar-2"
 :right "</p></div>")
#+END_SRC

When we have completly traversed ~input-tree~, we return the
concatenation of the left part and the right part of ~tree~.

Specifically, at the beginning of the programs we set the variables
~tree~, ~rest~, ~comps~ and ~comp~ that define the state of the program.

~tree~ is the tree we build a each iteration that contains the elements
needed to construct the final returned value.

~rest~ is the stack that contains the parts of ~input-tree~ left out to be
processed later.

~comps~ is the current list of components being treated.  Components in
~comps~ are at the same level in ~input-tree~.

~comp~ is the current component (always equal to the first element of
~comps~) that determines how we must update the state (~tree~, ~rest~ and
~comps~) of the program at each iteration:

1) when ~comp~ is ~nil~, we ignore this component and follow the
   traversal with the ~cdr~ of ~comps~,
2) when ~comp~ is a string or a number, we update ~tree~ by appending
   ~comp~ (as a string) to the left part of ~tree~, the right part staying
   the same,
3) when ~comp~ is a list of components we put them at the same level of
   the ~cdr~ of ~comps~, specifically we set ~comps~ to be ~(append comp
   (cdr comps))~,
4) when ~comp~ is a tag component, two cases must be distinguished
   according to the value of ~(cdr comps)~:
   1) if ~(cdr comps)~ is non-nil:
      - we update ~tree~ according to the value returned by ~osta-tag~ and
        by dividing the right part of ~tree~ into two parts,
      - we push the components ~(cdr comps)~ on the stack ~rest~ and,
      - the components to be treated in the next iteration are the
        children of the tag component ~comp~ (which can be either ~(cdr
        comp)~ or ~(cddr comp)~), so ~comps~ should be set to contains
        those children only, but as we need to remember that once
        those children has been treated we have to treat the element
        added to the stack ~rest~, we also append to ~comps~ the keyword
        ~:rest~,
   2) if ~(cdr comps)~ is nil:
      - it means that there is no part of ~input-tree~ to be added to
        the stack ~rest~ at this iteration, so ~rest~ stays unchanged,
      - we just update ~tree~ according to the value returned by
        ~osta-tag~ (without dividing the right part of ~tree~) and,
      - the components to be treated in the next iteration are the
        children of the tag component ~comp~ (which can be either ~(cdr
        comp)~ or ~(cddr comp)~), so ~comps~ is set to be those children,
5) when ~comp~ is the keyword ~:rest~, that means we have completed the
   traversal of a part of ~input-tree~, so:
   1) we update ~tree~ accordingly by appending the left part of the
      right part of ~tree~ to its left part, and we set its right part
      to be the right part of the right part of ~tree~,
   2) now we have to treat the most recently added list of components
      in the stack ~rest~.  To do so, we set ~comps~ to be the first
      element of ~rest~ and remove that first element from ~rest~ (this
      can be done like this ~(setq comps (pop rest))~),
6) when ~comp~ is any other object, we skip it or we raise an error
   depending on the variable ~osta-html-raise-error-p~.

Finally, when ~comp~ is ~nil~ and ~(cdr comps)~ too, it means that we have
completly traversed ~input-tree~, no more iterations are needed and we
return the concatenation of the left part and the right part of ~tree~.

** Running the program step by step

Let's go through each iteration that the following evaluation implies
by printing out and commenting the successive states of our program:

#+BEGIN_SRC emacs-lisp
(osta-html
 '(:div/foo.bar
   "A"
   (:p (@ :class "baz") "B" (:hr) "C")
   ("D" "E" "F")))
#+END_SRC

~input-tree~, ~tree~, ~rest~, ~comps~ and ~comp~ have the same meaning as in the
previous section.

And, each state of the program is representing as a plist where:

- ~:tree~ hold the value of ~tree~,
- ~:rest~ the value of ~rest~,
- ~:comps~ the value of ~comps~ and,
- ~:comp~ the value of ~comp~.

First the state is initialized like this (before entering in the ~while~
loop):

#+BEGIN_SRC emacs-lisp
(:tree (:left ""
        :right "")
 :rest nil
 :comps ((:div/foo.bar
          "A"
          (:p (@ :class "baz") "B" (:hr) "C")
          ("D" "E" "F")))
 :comp (:div/foo.bar
        "A"
        (:p (@ :class "baz") "B" (:hr) "C")
        ("D" "E" "F")))
#+END_SRC

As ~comp~ (equal to ~(:div/foo.bar ...)~) is a tag component, and is the
only component in ~comps~:

1) ~tree~ is updated with the left part and right part of the tag
   returned by ~osta-tag~ function,
2) ~rest~ stack stays ~nil~,
3) the components of ~input-tree~ that should be treated in the next
   iteration are the children of the tag ~comp~, which are the
   components at the same level of the string component ~"A"~,
   specifically, the new value of ~comps~ is ~cdr~ of the current ~comp~,

so the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">"
        :right "</div>")
 :rest nil
 :comps ("A"
         (:p (@ :class "baz") "B" (:hr) "C")
         ("D" "E" "F"))
 :comp "A")
#+END_SRC

As ~comp~ (equal to ~"A"~) is a string component,

1) we append ~"A"~ to the left part of ~tree~,
2) and we iterate on the ~cdr~ of the current ~comps~ (it means on the
   next components at the same level of ~"A"~ component),

so the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A"
        :right "</div>")
 :rest nil
 :comps ((:p (@ :class "baz") "B" (:hr) "C")
         ("D" "E" "F"))
 :comp (:p (@ :class "baz") "B" (:hr) "C"))
#+END_SRC

As ~comp~ (equal to ~(:p (@ :class "baz") ...)~) is a tag component but
not the only components in ~comps~:

1) ~tree~ is updated with the left part being the concatenation of its
   current left part and the left part of the tag returned by
   ~osta-tag~, and the right part is a subtree with its left part being
   the right part of the tag return by ~osta-tag~ and the right part
   being its current right part,
2) we push the ~cdr~ of ~comps~ to the stack ~rest~ in order to treat it
   after,
3) the components to be treated in the next iteration are the children
   of the tag component ~comp~ (which are the components at the same
   level of the string component ~"B"~), so ~comps~ should be set to
   contains those children only, but as we need to remember that once
   those children has been treated we have to treat the element added
   to the stack ~rest~, we also append to ~comps~ the keyword ~:rest~,

so the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">"
        :right (:left "</p>"
                :right "</div>"))
 :rest ((("D" "E" "F")))
 :comps ("B" (:hr) "C" :rest)
 :comp "B")
#+END_SRC

As ~comp~ (equal to ~"B"~) is a string component, we do the same thing we
did before for the string component ~"A"~ (note that the right part of
~tree~ and ~rest~ are unchanged).

So the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B"
        :right (:left "</p>"
                :right "</div>"))
 :rest ((("D" "E" "F")))
 :comps ((:hr) "C" :rest)
 :comp (:hr))
#+END_SRC

As ~comp~ (equal to ~(:hr)~) is a tag component but not the only
components in ~comps~:

1) ~tree~ is updated with the left part being the concatenation of its
   current left part and the left part of the tag returned by
   ~osta-tag~, and the right part is a subtree with its left part being
   the empty string ~""~ (because ~(:hr)~ is a void tag) and the right
   part being its current right part,
2) we push the ~cdr~ of ~comps~ to the stack ~rest~ in order to treat it
   after,
3) because ~(:hr)~ has no children, ~comps~ is the empty list to which we
   append the keyword ~:rest~ (for the same reason as before),

so the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />"
        :right (:left ""
                :right (:left "</p>"
                        :right "</div>")))
 :rest (("C" :rest) (("D" "E" "F")))
 :comps (:rest)
 :comp :rest)
#+END_SRC

As ~comp~ is equal to the keyword ~:rest~,

1) we update ~tree~ by appending the left part of the right part of ~tree~
   to its left part, and we set its right part to be the right part of
   the right part of ~tree~,
2) we set ~comps~ to be the most recently added list of components in
   the stack ~rest~ that we also remove from the stack,

so the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />"
        :right (:left "</p>"
                :right "</div>"))
 :rest ((("D" "E" "F")))
 :comps ("C" :rest)
 :comp "C")
#+END_SRC

As ~comp~ (equal to ~"C"~) is a string component, we do the same thing we
did before for the string components ~"A"~ and ~"B"~ (note that the right
part of ~tree~ and ~rest~ are unchanged).

So the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C"
        :right (:left "</p>"
                :right "</div>"))
 :rest ((("D" "E" "F")))
 :comps (:rest)
 :comp :rest)
#+END_SRC

As ~comp~ is equal to the keyword ~:rest~,

1) we update ~tree~ by appending the left part of the right part of ~tree~
   to its left part, and we set its right part to be the right part of
   the right part of ~tree~,
2) we set ~comps~ to be the most recently added list of components in
   the stack ~rest~ that we also remove from the stack,

so the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>"
        :right "</div>")
 :rest nil
 :comps (("D" "E" "F"))
 :comp ("D" "E" "F"))
#+END_SRC

As ~comp~ (equal to ~("D" "E" "F")~) is a list of components,
we put them at the same level of the ~cdr~ of ~comps~, specifically we set
~comps~ to be ~(append comp (cdr comps))~.  Note that ~tree~ is unchanged.

So the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>"
        :right "</div>")
 :rest nil
 :comps ("D" "E" "F")
 :comp "D")
#+END_SRC

As ~comp~ (equal to ~"D"~) is a string component, we do the same thing we
did before for the string components ~"A"~, ~"B"~ and ~"C"~ (note that the
right part of ~tree~ and ~rest~ are unchanged).

So the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>D"
        :right "</div>")
 :rest nil
 :comps ("E" "F")
 :comp "E")
#+END_SRC

As ~comp~ (equal to ~"E"~) is a string component, we do the same thing we
did before for the string components ~"A"~, ~"B"~, ~"C"~ and ~"D"~ (note that
the right part of ~tree~ and ~rest~ are unchanged).

So the new state is:

#+BEGIN_SRC emacs-lisp
(:tree
 (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>DE"
  :right "</div>")
 :rest nil
 :comps ("F")
 :comp "F")
#+END_SRC

As ~comp~ (equal to ~"F"~) is a string component, we do the same thing we
did before for the string components ~"A"~, ~"B"~, ~"C"~, ~"D"~ and ~"F"~ (note
that the right part of ~tree~ and ~rest~ are unchanged).

So the new state is:

#+BEGIN_SRC emacs-lisp
(:tree (:left "<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>DEF"
        :right "</div>")
 :rest nil
 :comps nil
 :comp nil)
#+END_SRC

At that point, as ~comp~ is ~nil~ and ~(cdr comps)~ too, we get out of the
loop.

That means that we have completely traversed ~input-tree~.

And now ~tree~ contains all the data we need to produce the html
string.

Eventually, we return the concatenation of the left part and the right
part of ~tree~.

#+BEGIN_SRC emacs-lisp
"<div id=\"foo\" class=\"bar\">A<p class=\"baz\">B<hr />C</p>DEF</div>"
#+END_SRC

** The code

In this section we reproduce the code of the function ~osta-html~ at
commit ~cd43e0b~.

But before doing so, as ~osta-html~ uses the function ~osta-tag~, we
describe it and give some examples that demonstrate its behavior.

The function ~osta-tag~ takes as input a keyword (representing a tag
maybe containing informations about its ~id~ or its ~class~) and
optionally a plist of attributes.  The function ~osta-tag~ returns a
plist describing the type of tag and its attributes that can be used
to produce html strings.

For instance:

1) Evaluating the form:

   #+BEGIN_SRC emacs-lisp
   (osta-tag :hr)
   #+END_SRC

   returns

   #+ATTR_OSTA_RESULTS:
   #+BEGIN_SRC emacs-lisp
   (:left "<hr />")
   #+END_SRC

2) Evaluating the form:

   #+BEGIN_SRC emacs-lisp
   (osta-tag :div/id.class)
   #+END_SRC

   returns

   #+ATTR_OSTA_RESULTS:
   #+BEGIN_SRC emacs-lisp
   (:left  "<div id=\"id\" class=\"class\">"
    :right "</div>")
   #+END_SRC

3) Evaluating the form:

   #+BEGIN_SRC emacs-lisp
   (osta-tag :div '(:id "id" :class "class"))
   #+END_SRC

   returns

   #+ATTR_OSTA_RESULTS:
   #+BEGIN_SRC emacs-lisp
   (:left  "<div id=\"id\" class=\"class\">"
    :right "</div>")
   #+END_SRC

With that said, here is the source code of ~osta-html~ at commit ~cd43e0b~:

#+BEGIN_SRC emacs-lisp
;; commit cd43e0bc6d2bf7affcc1fce0b071fa8f3f1978c0
;; Author: tony <tony.aldon.adm@gmail.com>
;; Date:   Mon Feb 7 10:51:35 2022 +0100

(defun osta-html (&rest components)
  ""
  (let* ((update-tree-comp
          (lambda (tree comp)
            (let* ((comp-str (if (stringp comp) comp (number-to-string comp)))
                   (left (concat (plist-get tree :left) comp-str))
                   (right (plist-get tree :right)))
              `(:left ,left :right ,right))))
         (update-tree-tag
          (lambda (tree tag new-rest)
            (let* ((tag-left (plist-get tag :left))
                   (left (concat (plist-get tree :left) tag-left))
                   (tag-right (or (plist-get tag :right) ""))
                   (tree-right (plist-get tree :right))
                   (right (if new-rest
                              `(:left ,tag-right :right ,tree-right)
                            (concat tag-right tree-right))))
              `(:left ,left :right ,right))))
         (update-tree-rest
          (lambda (tree)
            (let* ((tree-left (plist-get tree :left))
                   (tree-right-left (plist-get (plist-get tree :right) :left))
                   (tree-right-right (plist-get (plist-get tree :right) :right))
                   (left (concat tree-left tree-right-left)))
              `(:left ,left :right ,tree-right-right))))
         ;; initialize state
         (tree '(:left "" :right ""))
         rest
         (comps components)
         (comp (car comps)))
    (while (or comp (cdr comps))
      (pcase comp
        ;; nil component is just ignored
        ('nil
         (setq comps (cdr comps))
         (setq comp (car comps)))
        ;; string component or an integer component
        ((or (pred stringp) (pred numberp))
         (setq tree (funcall update-tree-comp tree comp))
         (setq comps (cdr comps))
         (setq comp (car comps)))
        ;; not a tag component but a list of components like '("foo" "bar")
        ((and (pred listp) (guard (not (keywordp (car comp)))))
         (setq comps (append comp (cdr comps)))
         (setq comp (car comps)))
        ;; tag component like '(:p "foo") or '(:p/id.class (@ :attr "attr") "foo")
        ((pred listp)
         (let ((new-rest (cdr comps)))
           (seq-let (tag comp-children)
               (seq-let (tag-kw attr) comp
                 ;; check if `attr' is of the form '(@ :id "id" :class "class")
                 (if (and (listp attr) (equal (car attr) '@))
                     (list (osta-tag tag-kw (cdr attr)) (cddr comp))
                   (list (osta-tag tag-kw) (cdr comp))))
             (setq tree (funcall update-tree-tag tree tag new-rest))
             (when new-rest (push new-rest rest))
             (setq comps (append comp-children (and new-rest '(:rest))))
             (setq comp (car comps)))))
        ;; make the latest list of components added to `rest' the
        ;; part of `components' to be treated in the next iteration
        (:rest
         (setq tree (funcall update-tree-rest tree))
         (setq comps (pop rest))
         (setq comp (car comps)))
        ;; non component object
        ((and _ obj)
         (when osta-html-raise-error-p
           (error "Object '%S' of type '%s' can't be a component in 'osta-html'"
                  obj (type-of obj)))
         (setq comps (cdr comps))
         (setq comp (car comps)))))
    (concat (plist-get tree :left) (plist-get tree :right))))
#+END_SRC

* Recursive vs. iterative implementation of osta-html in Elisp
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /recursive-vs-iterative-implementation-of-osta-html-in-elisp/
:OSTA_DATE: [2022-02-07 Mon]
:END:
** Push the limits

At commit ~554d733~ (2022-01-23), I finally got ~osta-html~ working and
passing the tests I wanted it to pass.  So, I had now a way to convert
components (Elisp data structure representing html) into html like
this:

#+BEGIN_SRC emacs-lisp
(osta-html '(:div (@ :id "id" :class "class") "foo"))
;; "<div id=\"id\" class=\"class\">foo</div>"

(osta-html `(:ul ,(mapcar (lambda (n) `(:li ,n)) '(1 2))))
;; "<ul><li>1</li><li>2</li></ul>"
#+END_SRC

I was happy but I also had the *feeling* that the implementation wasn't
"robust".

So I decided to push the limits of ~osta-html~ and gave it as input
"deep" nested lists of ~:div~ that looks like ~'(:div (:div (:div "foo")))~.

And for only ~46~ nested ~:div~, ~osta-html~ raised the following error:

#+ATTR_OSTA_RESULTS:
: (error "Lisp nesting exceeds ‘max-lisp-eval-depth’")

(Note that I use the default value of ~800~ for the variable
~max-lisp-eval-depth~.)

The help buffer about ~max-lisp-eval-depth~ variable tells us the
following:

#+BEGIN_SRC text
Limit on depth in ‘eval’, ‘apply’ and ‘funcall’ before error.

This limit serves to catch infinite recursions for you before they cause
actual stack overflow in C, which would be fatal for Emacs.
You can safely make it considerably larger than its default value,
if that proves inconveniently small.  However, if you increase it too far,
Emacs could overflow the real C stack, and crash.
#+END_SRC

At that point, I was:

1) *tired* (I didn't want to work more on ~osta-html~) but also,
2) *super excited* (life was offering me the opportunity to learn more
   about Elisp and programming).

The first implementation (commit ~554d733~) uses recursive calls to
traverse the tree (Elisp data structure representing the html).

Too many calls to the function ~apply~ were causing the error.

I thought about making the recursive calls in tail position (not the
case in the implementation ~554d733~).  But, after some readings ([[https://stackoverflow.com/questions/38493904/why-is-there-no-tail-recursion-optimization-in-emacs-lisp-not-but-like-other-sc][Why is
there no tail recursion optimization in Emacs lisp? (stackoverflow)]]),
I learned that this wasn't the way to go, because:

1) Elisp doesn't implement tail-recursion optimization and,
2) the implementation of function calls is "relatively inefficient"
   anyway.

Considering these "new" elements (for me), instead of forcing Elisp to
do something it didn't want to do, I decided to re-implement ~osta-html~
in an iterative way (commit ~cd43e0b~ (2022-02-07)).

Thus now, the new implementation:

1) passes the same tests (as the recursive one) regarding of the
   expected functionalities,
2) works fine with more than ~10000~ nested ~:div~ (can do more) and,
3) has "more or less" the same performances as the recursive one (If
   you know how to do good performance tests, *please reach out*, I'm
   eager to learn).

If you are interested, you can find below the two implementations of
~osta-html~:

1) the recursive one named ~osta-html-REC~ and,
2) the iterative one named ~osta-html-ITER~.

There is also a section that tests the functionalities of both
implementations.

The last section tests its "robustness".

Note that when I was re-implementing ~osta-html~ in an iterative way, I
also changed the way ~osta-html~ builds the html strings removing the
use of the function ~format~ that was causing wrong results with string
components containing ~%s~ strings.

** ~osta-html-REC~ (recursive implementation of ~osta-html~)

#+BEGIN_SRC emacs-lisp
;; commit 554d7337df242124822b6adcada50d1a99bac4a4
;; Author: tony <tony.aldon.adm@gmail.com>
;; Date:   Sun Jan 23 10:08:13 2022 +0100

(defvar osta-html-raise-error-p-REC nil "")

(defun osta-parse-tag-kw-REC (tag-kw)
  "Return a list of (\"tag\" \"id\" \"class\") from a TAG-KW."
  (if-let* (((keywordp tag-kw))
            (tag-s (symbol-name tag-kw))
            ((string-match (concat "\\(?::\\)\\([^ /.]+\\)"
                                   "\\(?:/\\([^ /.]+\\)\\)?"
                                   "\\(?:[.]\\([^ /]+\\)\\)?")
                           tag-s)))
      (let* ((tag (match-string 1 tag-s))
             (id (match-string 2 tag-s))
             (class (match-string 3 tag-s))
             (classes (and class (string-replace "." " " class))))
        (if (or tag id classes)
            (list tag id classes)
          (error "Wrong tag keyword: %S" tag-kw)))
    (error "Wrong tag keyword: %S" tag-kw)))

(defun osta-format-REC (tag-kw &optional attributes)
  ""
  (let ((void-tags '("area" "base" "br" "col" "embed" "hr" "img" "input"   ; https://developer.mozilla.org/en-US/docs/Glossary/Empty_element
                     "keygen" "link" "meta" "param" "source" "track" "wbr")))
    (seq-let (tag id classes) (osta-parse-tag-kw-REC tag-kw)
      (let* ((fmt (if (member tag void-tags) "<%s%s />" "<%s%s>%%s</%s>"))
             (kw->a (lambda (kw) (substring (symbol-name kw) 1))) ; :id -> "id"
             (p->a-v                                              ; (:id "foo") -> "id=\"foo\""
              (lambda (p)
                (let ((attr (funcall kw->a (car p))))
                  (pcase (eval (cadr p))
                    ('t (format "%s=\"%s\"" attr attr))
                    ('nil nil)
                    ((and _ value) (format "%s=\"%s\"" attr (osta-escape value)))))))
             (pairs (seq-partition attributes 2))
             ;; we merge classes from `tag-kw' and `attribute' and add it to the pairs
             (-pairs (if classes
                         (if-let* ((c (assoc :class pairs)))
                             (let* ((pairs-without-class
                                     (seq-remove
                                      (lambda (p) (eq (car p) :class)) pairs))
                                    (class-value-in-pairs (cadr c))
                                    (class `(:class ,(concat classes " " class-value-in-pairs))))
                               (cons class pairs-without-class))
                           (cons `(:class ,classes) pairs))
                       pairs))
             ;; `id' in `attributes' has priority over `id' in `tag-kw'
             (--pairs (if (and id (not (assoc :id -pairs)))
                          (cons `(:id ,id) -pairs)
                        -pairs))
             (attrs (string-join (delq nil (mapcar p->a-v --pairs)) " "))
             (-attrs (if (string-empty-p attrs) "" (concat " " attrs))))
        (format fmt tag -attrs tag)))))

(defun osta-html-REC (&rest components)
  ""
  (let (children)
    (pcase (car components)
      ((and 'nil (guard (null (cdr components)))) "")
      ;; (car components) is a string component or an integer component
      ((and (or (pred stringp) (pred numberp)) component)
       (push (format "%s" component) children)
       (push (apply #'osta-html-REC (cdr components)) children))
      ;; (car components) is not a tag component but a list of components
      ;; like this '((:p "foo") "bar" 1)
      ((and (pred listp) l (guard (not (keywordp (car l)))))
       (let ((-components (append l (cdr components))))
         (push (apply #'osta-html-REC -components) children)))
      ((and (pred listp) component)
       (seq-let (tag-kw attr-or-comp comp) component
         (pcase attr-or-comp
           ;; empty component like '(:p)
           ('nil
             (push (format (osta-format-REC tag-kw) (apply #'osta-html-REC nil)) children))
           ;; attr-or-comp is attributes plist like '(@ :id "id" :class "class")
           ((and (pred listp) (pred (lambda (l) (equal (car l) '@))))
            (let ((-components (cddr component))
                  (fmt (osta-format-REC tag-kw (cdr attr-or-comp))))
              (push (format fmt (apply #'osta-html-REC -components)) children)))
           (_ (let ((-components (cdr component))
                    (fmt (osta-format-REC tag-kw)))
                (push (format fmt (apply #'osta-html-REC -components)) children)))))
       (push (apply #'osta-html-REC (cdr components)) children))
      ((and _ obj)
       (when osta-html-raise-error-p-REC
         (error "Object '%S' of type '%s' can't be a component in 'osta-html-REC'"
                obj (type-of obj)))
       (push (apply #'osta-html-REC (cdr components)) children)))
    (apply #'concat (nreverse children))))
#+END_SRC

** ~osta-html-ITER~ (iterative implementation of ~osta-html~)

#+BEGIN_SRC emacs-lisp
;; commit cd43e0bc6d2bf7affcc1fce0b071fa8f3f1978c0
;; Author: tony <tony.aldon.adm@gmail.com>
;; Date:   Mon Feb 7 10:51:35 2022 +0100

(defvar osta-html-raise-error-p-ITER nil "")

(defun osta-parse-tag-kw-ITER (tag-kw)
  "Return a list of (\"tag\" \"id\" \"class\") from a TAG-KW."
  (if-let* (((keywordp tag-kw))
            (tag-s (symbol-name tag-kw))
            ((string-match (concat "\\(?::\\)\\([^ /.]+\\)"
                                   "\\(?:/\\([^ /.]+\\)\\)?"
                                   "\\(?:[.]\\([^ /]+\\)\\)?")
                           tag-s)))
      (let* ((tag (match-string 1 tag-s))
             (id (match-string 2 tag-s))
             (class (match-string 3 tag-s))
             (classes (and class (string-replace "." " " class))))
        (if (or tag id classes)
            (list tag id classes)
          (error "Wrong tag keyword: %S" tag-kw)))
    (error "Wrong tag keyword: %S" tag-kw)))

(defun osta-tag-ITER (tag-kw &optional attributes)
  "Return a plist describing the type of TAG-KW and its ATTRIBUTES."
  (let ((void-tags '("area" "base" "br" "col" "embed" "hr" "img" "input"   ; https://developer.mozilla.org/en-US/docs/Glossary/Empty_element
                     "keygen" "link" "meta" "param" "source" "track" "wbr")))
    (seq-let (tag id classes) (osta-parse-tag-kw-ITER tag-kw)
      (let* ((kw->a (lambda (kw) (substring (symbol-name kw) 1))) ; :id -> "id"
             (p->a-v                                              ; (:id "foo") -> "id=\"foo\""
              (lambda (p)
                (let ((attr (funcall kw->a (car p))))
                  (pcase (eval (cadr p))
                    ('t (concat attr "=\""  attr "\""))
                    ('nil nil)
                    ((and _ value)
                     (concat attr "=\"" (osta-escape value) "\""))))))
             (pairs (seq-partition attributes 2))
             ;; we merge classes from `tag-kw' and `attributes' and add it to the pairs
             (-pairs (if classes
                         (if-let* ((c (assoc :class pairs)))
                             (let* ((pairs-without-class
                                     (seq-remove
                                      (lambda (p) (eq (car p) :class)) pairs))
                                    (class-value-in-pairs (cadr c))
                                    (class `(:class ,(concat classes " " class-value-in-pairs))))
                               (cons class pairs-without-class))
                           (cons `(:class ,classes) pairs))
                       pairs))
             ;; `id' in `attributes' has priority over `id' in `tag-kw'
             (--pairs (if (and id (not (assoc :id -pairs)))
                          (cons `(:id ,id) -pairs)
                        -pairs))
             (attrs (string-join (delq nil (mapcar p->a-v --pairs)) " "))
             (-attrs (if (string-empty-p attrs) "" (concat " " attrs))))
        (if (member tag void-tags)
            `(:left ,(concat "<" tag -attrs " />"))
          `(:left  ,(concat "<" tag -attrs ">")
            :right ,(concat "</" tag ">")))))))

(defun osta-html-ITER (&rest components)
  ""
  (let* ((update-tree-comp
          (lambda (tree comp)
            (let* ((comp-str (if (stringp comp) comp (number-to-string comp)))
                   (left (concat (plist-get tree :left) comp-str))
                   (right (plist-get tree :right)))
              `(:left ,left :right ,right))))
         (update-tree-tag
          (lambda (tree tag new-rest)
            (let* ((tag-left (plist-get tag :left))
                   (left (concat (plist-get tree :left) tag-left))
                   (tag-right (or (plist-get tag :right) ""))
                   (tree-right (plist-get tree :right))
                   (right (if new-rest
                              `(:left ,tag-right :right ,tree-right)
                            (concat tag-right tree-right))))
              `(:left ,left :right ,right))))
         (update-tree-rest
          (lambda (tree)
            (let* ((tree-left (plist-get tree :left))
                   (tree-right-left (plist-get (plist-get tree :right) :left))
                   (tree-right-right (plist-get (plist-get tree :right) :right))
                   (left (concat tree-left tree-right-left)))
              `(:left ,left :right ,tree-right-right))))
         ;; initialize state
         (tree '(:left "" :right ""))
         rest
         (comps components)
         (comp (car comps)))
    (while (or comp (cdr comps))
      (pcase comp
        ;; nil component is just ignored
        ('nil
         (setq comps (cdr comps))
         (setq comp (car comps)))
        ;; string component or an integer component
        ((or (pred stringp) (pred numberp))
         (setq tree (funcall update-tree-comp tree comp))
         (setq comps (cdr comps))
         (setq comp (car comps)))
        ;; not a tag component but a list of components like '("foo" "bar")
        ((and (pred listp) (guard (not (keywordp (car comp)))))
         (setq comps (append comp (cdr comps)))
         (setq comp (car comps)))
        ;; tag component like '(:p "foo") or '(:p/id.class (@ :attr "attr") "foo")
        ((pred listp)
         (let ((new-rest (cdr comps)))
           (seq-let (tag comp-children)
               (seq-let (tag-kw attr) comp
                 ;; check if `attr' is of the form '(@ :id "id" :class "class")
                 (if (and (listp attr) (equal (car attr) '@))
                     (list (osta-tag-ITER tag-kw (cdr attr)) (cddr comp))
                   (list (osta-tag-ITER tag-kw) (cdr comp))))
             (setq tree (funcall update-tree-tag tree tag new-rest))
             (when new-rest (push new-rest rest))
             (setq comps (append comp-children (and new-rest '(:rest))))
             (setq comp (car comps)))))
        ;; make the latest list of components added to `rest' the
        ;; part of `components' to be treated in the next iteration
        (:rest
         (setq tree (funcall update-tree-rest tree))
         (setq comps (pop rest))
         (setq comp (car comps)))
        ;; non component object
        ((and _ obj)
         (when osta-html-raise-error-p-ITER
           (error "Object '%S' of type '%s' can't be a component in 'osta-html-ITER'"
                  obj (type-of obj)))
         (setq comps (cdr comps))
         (setq comp (car comps)))))
    (concat (plist-get tree :left) (plist-get tree :right))))
#+END_SRC

** Test the functionalities

#+BEGIN_SRC emacs-lisp
(ert-deftest osta-html-functionality ()
  (let ((osta-html-raise-error-p nil))
    ;; `osta-html-REC'
    (should (string= (osta-html-REC nil) ""))
    (should (string= (osta-html-REC "foo") "foo"))
    (should (string= (osta-html-REC 16) "16"))
    (should (string= (osta-html-REC '(:hr)) "<hr />"))
    (should (string= (osta-html-REC '(:div (@ :id "id" :class "class") "foo"))
                     "<div id=\"id\" class=\"class\">foo</div>"))
    (should (string= (osta-html-REC '("foo" 1 "bar")) "foo1bar"))
    (should (string= (osta-html-REC '(:ul ((:li "1") (:li "2"))))
                     "<ul><li>1</li><li>2</li></ul>"))
    (should (string=
             (osta-html-REC `(:ul ,(mapcar (lambda (n) `(:li ,n)) '(1 2))))
             "<ul><li>1</li><li>2</li></ul>"))
    (should (string= (osta-html-REC (mapcar (lambda (n) `(:p ,n)) '(1 2 3)))
                     "<p>1</p><p>2</p><p>3</p>"))
    (should (string= (let ((x "foo") (y "bar"))
                       (osta-html-REC `(:p (@ :id ,x) ,y)))
                     "<p id=\"foo\">bar</p>"))
    (should (string= (osta-html-REC
                      (let ((x "foo") (y "bar"))
                        `(:p (@ :id ,x) ,y)))
                     "<p id=\"foo\">bar</p>"))

    ;; `osta-html-ITER'
    (should (string= (osta-html-ITER nil) ""))
    (should (string= (osta-html-ITER "foo") "foo"))
    (should (string= (osta-html-ITER 16) "16"))
    (should (string= (osta-html-ITER '(:hr)) "<hr />"))
    (should (string= (osta-html-ITER '(:div (@ :id "id" :class "class") "foo"))
                     "<div id=\"id\" class=\"class\">foo</div>"))
    (should (string= (osta-html-ITER '("foo" 1 "bar")) "foo1bar"))
    (should (string= (osta-html-ITER '(:ul ((:li "1") (:li "2"))))
                     "<ul><li>1</li><li>2</li></ul>"))
    (should (string=
             (osta-html-ITER `(:ul ,(mapcar (lambda (n) `(:li ,n)) '(1 2))))
             "<ul><li>1</li><li>2</li></ul>"))
    (should (string= (osta-html-ITER (mapcar (lambda (n) `(:p ,n)) '(1 2 3)))
                     "<p>1</p><p>2</p><p>3</p>"))
    (should (string= (let ((x "foo") (y "bar"))
                       (osta-html-ITER `(:p (@ :id ,x) ,y)))
                     "<p id=\"foo\">bar</p>"))
    (should (string= (osta-html-ITER
                      (let ((x "foo") (y "bar"))
                        `(:p (@ :id ,x) ,y)))
                     "<p id=\"foo\">bar</p>"))))
#+END_SRC

** Test the robustness
*** 50 nested ~:div~ vs. 10000 nested ~:div~

#+BEGIN_SRC emacs-lisp
(defun nested-foo-comp (n)
  "Construct nested list where car is the keyword :div.
For instance: (nested-foo-comp 3) -> (:div (:div (:div \"foo\")))"
  (let ((comp "foo"))
    (dotimes (_ n) (setq comp (list :div comp)))
    comp))

(ert-deftest osta-html-lisp-nesting ()
  (let ((max-lisp-eval-depth 800)) ; default value
    ;; `osta-html-REC'
    ;; (error "Lisp nesting exceeds ‘max-lisp-eval-depth’")
    (let ((comp (nested-foo-comp 50)))
      (should-error (osta-html-REC comp)))

    ;; `osta-html-ITER'
    (message "Might take a few seconds...")
    (let ((comp (nested-foo-comp 10000)))
      (should (osta-html-ITER comp)))))
#+END_SRC

*** Performance

#+BEGIN_SRC emacs-lisp
(let ((comp '(:p "foo")))
  (dolist (osta-html '(osta-html-REC osta-html-ITER))
    (message "------------------------------------")
    (dotimes (_ 15)
      (garbage-collect)
      (apply #'message "%-15s %10.6f %3d %.3f" osta-html
               (benchmark-run 10 (funcall osta-html comp))))))
#+END_SRC

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC text
------------------------------------
osta-html-REC     0.000304   0 0.000
osta-html-REC     0.000201   0 0.000
osta-html-REC     0.000204   0 0.000
osta-html-REC     0.000240   0 0.000
osta-html-REC     0.000202   0 0.000
osta-html-REC     0.000207   0 0.000
osta-html-REC     0.000199   0 0.000
osta-html-REC     0.000245   0 0.000
osta-html-REC     0.000195   0 0.000
osta-html-REC     0.000199   0 0.000
osta-html-REC     0.000217   0 0.000
osta-html-REC     0.000189   0 0.000
osta-html-REC     0.000204   0 0.000
osta-html-REC     0.000194   0 0.000
osta-html-REC     0.000201   0 0.000
------------------------------------
osta-html-ITER    0.000171   0 0.000
osta-html-ITER    0.000179   0 0.000
osta-html-ITER    0.000180   0 0.000
osta-html-ITER    0.000188   0 0.000
osta-html-ITER    0.000189   0 0.000
osta-html-ITER    0.000182   0 0.000
osta-html-ITER    0.000185   0 0.000
osta-html-ITER    0.000244   0 0.000
osta-html-ITER    0.000184   0 0.000
osta-html-ITER    0.000182   0 0.000
osta-html-ITER    0.000181   0 0.000
osta-html-ITER    0.000222   0 0.000
osta-html-ITER    0.000220   0 0.000
osta-html-ITER    0.000214   0 0.000
osta-html-ITER    0.000182   0 0.000
#+END_SRC

* Documentation
** org elements not supported
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /doc/org-elements-not-supported/
:END:

I left out many org elements:
- I don't do math.  No support for Latex,
- I don't use images.  No support for images.
- etc.

You can find the complete list of the org elements that are not
supported in the commentary section of the file ~osta.el~

Read more: [[#/why-osta/][Why osta?]].

** src-block
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /doc/src-block/
:END:
*** code highlighting with ~htmlize.el~
**** description

~osta~ highlights code via the function ~osta-ox-htmlize~ that uses
~htmlize.el~ to do the work.

For a given piece of code ~X~ in a certain language ~Y~, ~X~ will be
highlighted as it would be in the emacs mode ~Z~ used to edit ~Y~ code.

For instance, ~clojure-mode~ is used to highlight Clojure code and
~sh-mode~ is used to highlight Bash code.

Attributes of a face (like ~background-color~ or ~foreground-color~)
are not taken directly.  A generated name for the face is produced and
used as the CSS class for the parts of the code ~X~ that are highlighted
with that face.

For instance, in ~sh-mode~, the word ~echo~ is highlighted with the face
~font-lock-builtin-face~.  So, the word ~echo~ in a piece of Shell (or
Bash) code will be transformed into:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<span class="osta-hl-builtin">echo</span>
#+END_SRC

The whole piece of code ~X~, once the previously described operations
have been done, is wrapped:

1) for a /normal/ block by the component:

   #+ATTR_OSTA_RESULTS:
   #+BEGIN_SRC html
   <pre><code class="osta-hl osta-hl-block">...</code></pre>
   #+END_SRC

2) for a /result/ block by the component:

   #+ATTR_OSTA_RESULTS:
   #+BEGIN_SRC html
   <pre><code class="osta-hl osta-hl-results">...</code></pre>
   #+END_SRC

See section [[#/doc/src-block/#org-keywords-results-and-attr_osta_results][org keywords RESULTS and ATTR_OSTA_RESULTS]].

**** example with Bash code

For instance, the following org src-block, containing some ~bash~ code:

#+BEGIN_SRC text
,#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
,#+END_SRC
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<pre><code class="osta-hl osta-hl-block"><span class="osta-hl-builtin">echo</span> <span class="osta-hl-string">"list file's extensions in current dir:"</span>
<span class="osta-hl-keyword">for</span> f<span class="osta-hl-keyword"> in</span> <span class="osta-hl-sh-quoted-exec">`ls`</span>; <span class="osta-hl-keyword">do</span>
    <span class="osta-hl-builtin">echo</span> ${<span class="osta-hl-variable-name">f</span>##*.}
<span class="osta-hl-keyword">done</span></code></pre>
</div>
#+END_SRC

and rendered like this:

#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
#+END_SRC

Note that ~osta-ox-htmlize~ has produced and used the following CSS
classes (listed with their corresponding emacs faces):

#+BEGIN_SRC text
# from font-lock
osta-hl-builtin        --> font-lock-builtin-face
osta-hl-keyword        --> font-lock-keyword-face
osta-hl-string         --> font-lock-string-face
osta-hl-variable-name  --> font-lock-variable-name-face

# specific to sh-mode
osta-hl-sh-quoted-exec --> sh-quoted-exec
#+END_SRC

You might have notice the pattern used for ~font-lock~ faces and the one
used for mode specific faces.

~osta~ provides a style sheet that has the CSS classes defined for all
the ~font-lock~ faces (faces starting by ~font-lock-~) but not the
specific faces used by each prog mode (except the ones I use often).

You can add the CSS classes specific to the prog modes you use as you
go and need them.

**** Bash, Clojure and Elisp chunks of code

Bash, Clojure and Elisp languages are the ones I want to talk about.
And I'm sure they will appear in my tech writing.  So here they are:

Bash code:

#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
#+END_SRC

Clojure code:

#+BEGIN_SRC clojure
(defn str
  "With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args."
  {:tag String
   :added "1.0"
   :static true}
  (^String [] "")
  (^String [^Object x]
   (if (nil? x) "" (. x (toString))))
  (^String [x & ys]
     ((fn [^StringBuilder sb more]
          (if more
            (recur (. sb  (append (str (first more)))) (next more))
            (str sb)))
      (new StringBuilder (str x)) ys)))
#+END_SRC

Elisp code:

#+BEGIN_SRC emacs-lisp
(defconst clojure-font-lock-keywords
  (eval-when-compile
    `( ;; Top-level variable definition
      (,(concat "(\\(?:clojure.core/\\)?\\("
                (regexp-opt '("def" "defonce"))
                ;; variable declarations
                "\\)\\>"
                ;; Any whitespace
                "[ \r\n\t]*"
                ;; Possibly type or metadata
                "\\(?:#?^\\(?:{[^}]*}\\|\\sw+\\)[ \r\n\t]*\\)*"
                "\\(\\sw+\\)?")
       (1 font-lock-keyword-face)
       (2 font-lock-variable-name-face nil t))
      ;; ...
      )))
#+END_SRC

*** org keywords ~RESULTS~ and ~ATTR_OSTA_RESULTS~
:PROPERTIES:
:CUSTOM_ID: /doc/src-block/#org-keywords-results-and-attr_osta_results
:END:

A *block* is considered to be a /result/ block:
1) if it is preceded by a line starting by ~#+RESULTS:~ or,
2) if it is preceded by a line starting by ~#+ATTR_OSTA_RESULTS:~.

Blocks that are not /result/ blocks are /normal/ blocks.

When exported, /normal/ blocks and /result/ blocks differ only by their
CSS classes:
- ~osta-hl osta-hl-block~ for /normal/ blocks,
- ~osta-hl osta-hl-results~ for /result/ blocks.

This way /result/ blocks can be rendered with a different style
than /normal/ blocks as we can see in the following 2 examples.

**** example using org keyword ~RESULTS~

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_SRC bash :results output
ls
,#+END_SRC

,#+RESULTS:
: content.org
: osta.css
: osta.el
: README.org
#+END_SRC

is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<pre><code class="osta-hl osta-hl-block">ls</code></pre>
<pre><code class="osta-hl osta-hl-results">content.org
osta.css
osta.el
README.org</code></pre>
#+END_SRC

and is rendered by ~osta~ with the first block (/normal/ block) having a
different style from second block (/result/ block):

#+BEGIN_SRC bash :results output
ls
#+END_SRC

#+RESULTS:
: content.org
: osta.css
: osta.el
: README.org

**** example using org keyword ~ATTR_OSTA_RESULTS~

The following org snippet:

#+BEGIN_SRC text
After evaluating this code block:

,#+BEGIN_SRC emacs-lisp
(plist-get '(:a "aaa" :b (:c "ccc" :d "ddd")) :b)
,#+END_SRC

we get:

,#+ATTR_OSTA_RESULTS:
,#+BEGIN_SRC emacs-lisp
(:c "ccc" :d "ddd")
,#+END_SRC
#+END_SRC

is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<p>After evaluating this code block:</p>
<pre><code class="osta-hl osta-hl-block">(plist-get '(<span class="osta-hl-builtin">:a</span> <span class="osta-hl-string">"aaa"</span> <span class="osta-hl-builtin">:b</span> (<span class="osta-hl-builtin">:c</span> <span class="osta-hl-string">"ccc"</span> <span class="osta-hl-builtin">:d</span> <span class="osta-hl-string">"ddd"</span>)) <span class="osta-hl-builtin">:b</span>)</code></pre>
<p>we get:</p>
<pre><code class="osta-hl osta-hl-results">(<span class="osta-hl-builtin">:c</span> <span class="osta-hl-string">"ccc"</span> <span class="osta-hl-builtin">:d</span> <span class="osta-hl-string">"ddd"</span>)</code></pre>
#+END_SRC

and is rendered by ~osta~ like this:

After evaluating this code block:

#+BEGIN_SRC emacs-lisp
(plist-get '(:a "aaa" :b (:c "ccc" :d "ddd")) :b)
#+END_SRC

we get:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC emacs-lisp
(:c "ccc" :d "ddd")
#+END_SRC

*** code blocks inside list

Lists can contain src-block as we can see in the following org
snippet:

#+BEGIN_SRC text
1. item 1

   ,#+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   ,#+END_SRC

2. item 2
3. item 3
#+END_SRC

that is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<ol>
  <li>
    <p>item 1</p>
    <pre><code class="osta-hl osta-hl-block">(message <span class="osta-hl-string">"src-block in item 1"</span>)</code></pre>
  </li>
  <li><p>item 2</p></li>
  <li><p>item 3</p></li>
</ol>
#+END_SRC

and is rendered by ~osta~ like this:

1. item 1

   #+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   #+END_SRC

2. item 2
3. item 3

** quote-block
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /doc/quote-block/
:END:

Blocks defined with ~#+BEGIN_QUOTE ... #+END_QUOTE~ pattern are
quote-block.

They are exported by ~osta~ in a ~<blockquote>...</blockquote>~ component
with the CSS class ~osta-blockquote~.

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
,#+END_QUOTE
#+END_SRC

defines a quote and is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<blockquote class="osta-blockquote">A quitter never wins and a winner never quits. —Napoleon Hill</blockquote>
#+END_SRC

and look like this:

#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
#+END_QUOTE

** fixed-width and example-block
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /doc/fixed-width-and-example-block/
:END:
*** description

A line starting with a colon ~:~ followed by a space defined a
fixed-width element.  A fixed-width element can span several
lines.

fixed-width elements are blocks.

Blocks defined with ~#+BEGIN_EXAMPLE ... #+END_EXAMPLE~ pattern are
example-block elements.

Both fixed-width and example-block blocks are treated as [[#/doc/src-block/][src-block]] in
~text-mode~.  So:

1) they are highlighted as ~text-mode~ would do,
2) they are rendered in a ~<pre><code>...</code></pre>~ component
   (indentation and newlines are respected),
3) they are /normal/ blocks (with CSS classes ~osta-hl osta-hl-block~) *OR*
   /result/ blocks (with CSS classes ~osta-hl osta-hl-results~).

*** example

The following org snippet:

#+BEGIN_SRC text
Here is a fixed-width element (one line):

: I'm a fixed-width element

fixed-width elements can also be used within lists:

- item 1
  : fixed-width element
- item 2
  ,#+ATTR_OSTA_RESULTS:
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use example blocks, here is one:

,#+BEGIN_EXAMPLE
This    is
        an    example!
,#+END_EXAMPLE
#+END_SRC

is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<p>Here is a fixed-width element (one line):</p>

<pre><code class="osta-hl osta-hl-block">I'm a fixed-width element</code></pre>

<p>fixed-width elements can also be used within lists:</p>

<ul>
  <li>
    <p>item 1</p>
    <pre><code class="osta-hl osta-hl-block">fixed-width element</code></pre>
  </li>
  <li>
    <p>item 2</p>
    <pre><code class="osta-hl osta-hl-results">multiline fixed-width element
that is also a result block,
so has a different style.</code></pre>
  </li>
</ul>

<p>Although I don&apos;t often use example blocks, here is one:</p>

<pre><code class="osta-hl osta-hl-block">This    is
        an    example!</code></pre>
#+END_SRC

and look like this:

Here is a fixed-width element (one line):

: I'm a fixed-width element

fixed-width elements can also be used within lists:

- item 1
  : fixed-width element
- item 2
  #+ATTR_OSTA_RESULTS:
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use example blocks, here is one:

#+BEGIN_EXAMPLE
This    is
        an    example!
#+END_EXAMPLE

** links
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /doc/links
:END:
*** http, https, mailto links

- http://tonyaldon.com,
- [[https://tonyaldon.com][Tony Aldon (https)]],
- [[mailto:aldon.tony.adm@gmail.com][send me an email]].

Web links (starting by ~http~ or ~https~) and links to message
composition (starting by ~mailto~) are exported as you expect.

For instance the following link:

#+BEGIN_SRC text
http://tonyaldon.com
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="http://tonyaldon.com">http://tonyaldon.com</a>
#+END_SRC

and this following link with a description:

#+BEGIN_SRC text
[[https://tonyaldon.com][Tony Aldon (https)]]
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="https://tonyaldon.com">Tony Aldon (https)</a>
#+END_SRC

and this ~mailto~ link:

#+BEGIN_SRC text
[[mailto:aldon.tony.adm@gmail.com][send me an email]]
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="mailto:aldon.tony.adm@gmail.com">send me an email</a>
#+END_SRC

*** custom-id links

- [[#/doc/plain-list-and-item/][page about plain-list]],
- [[#/doc/plain-list-and-item/#unordered-lists][unordered lists heading in the page about plain-list]].

**** description

In ~osta~, ~CUSTOM_ID~ properties are:

- paths to pages (if the corresponding headline has also the property
  ~OSTA_PAGE~ set to ~t~):

  #+BEGIN_SRC text
  ,* Page 1
  :PROPERTIES:
  :OSTA_PAGE: t
  :CUSTOM_ID: /blog/page-1/
  :END:
  #+END_SRC

- or paths to a specific heading (headline in org parlance) inside
  pages:

  #+BEGIN_SRC text
  ,* Page 1
  :PROPERTIES:
  :OSTA_PAGE: t
  :CUSTOM_ID: /blog/page-1/
  :END:
  ,** headline 1 in page Page 1
  :PROPERTIES:
  :CUSTOM_ID: /blog/page-1/#headline-1
  :END:
  #+END_SRC

Those paths define valid web urls starting at the root of the website
if you respect (you must):

1) url-encoded characters,
2) start them with a ~/~,
3) use ~#~ character to start the last part of the path when you're
   targeting a heading tag with its ~id~ being the last part after the ~#~
   character.

The benefits of these "rules/conventions" are:

1) ~osta~ not need to compute anything regarding of the paths of the
   pages,
2) ~osta~ can leave ~custom-id~ links as they are,
3) navigation between ~osta~ pages (specific headlines) inside emacs
   using ~custom-id~ links is *not broken*!  (This is a big win for the
   writer of the blog who can enjoy his own blog inside emacs!!!).

Precisely, the following link to the ~custom-id~ equal to ~/blog/page-1/~:

#+BEGIN_SRC text
[[#/blog/page-1/][Page 1]]
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/blog/page-1/">Page 1</a>
#+END_SRC

**** example (link to a page)

The following link to the headline with ~CUSTOM_ID~ equal to
~/doc/plain-list-and-item/~ (that is also an ~osta~ page):

#+BEGIN_SRC text
[[#/doc/plain-list-and-item/][page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the page ~/doc/plain-list-and-item/~:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item/">page about plain-list</a>
#+END_SRC

and is rendered like this: [[#/doc/plain-list-and-item/][page about plain-list]].

**** example (link to a headline in a page)

The following link to the headline with ~CUSTOM_ID~ equal to
~/doc/plain-list-and-item/#unordered-lists~ (that must be a subsection of the
~osta~ page ~/doc/plain-list-and-item/~):

#+BEGIN_SRC text
[[#/doc/plain-list-and-item/#unordered-lists][unordered lists heading in the page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the heading with the ~id~
set to ~unordered-lists~ on the page ~/doc/plain-list-and-item/~:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item/#unordered-lists">unordered lists heading in the page about plain-list</a>
#+END_SRC

and is rendered like this: [[#/doc/plain-list-and-item/#unordered-lists][unordered lists heading in the page about
plain-list]].

*** fuzzy links

# uncomment the last line of this comment (fuzzy search link),
# narrow the buffer to this subsection, and export the narrowed
# buffer with osta.
# --> This must raise an error.
# --> [[fuzzy search]]

I don't use ~fuzzy~ links.  So, if there is a ~fuzzy~ link
in the document, that means I wrote the link wrong.

Broken links are bad user experience.  I don't like them.

So I decided that ~osta~ raises an error (hard-coded) when we try to
export a fuzzy link to HTML.

For instance, the following ~fuzzy~ link:

#+BEGIN_SRC text
[[fuzzy search]]
#+END_SRC

raise an error like the following:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC text
(osta-link-broken "fuzzy search" "fuzzy links not supported" "goto-char: 5523")
#+END_SRC

*** file links
**** links to local files mapped to web urls (~OSTA_LINK~)
:PROPERTIES:
:CUSTOM_ID: /doc/links/#local-files-mapped-to-web-urls
:END:

# we've put the #+LINK: statments here to have
# this section about links self-contained, thought
# it is better practice to put it at the beginning
# of the org file.

#+LINK: clj ./clojure/

# mapped links between local files and web urls are
# declared with the osta org keyword OSTA_LINK.

#+OSTA_LINK: /tmp/clojurescript/ --> https://github.com/clojure/clojurescript
#+OSTA_LINK: clj:src/clj/clojure/core.clj::(defn str --> https://github.com/clojure/clojure/blob/abe19832c0294fec4c9c55430c9262c4b6d2f8b1/src/clj/clojure/core.clj#L546

# to make those following links works correctly inside emacs,
# you must have:
# 1) ClojureScript repository cloned under the directory /tmp/clojurescript/:
   # git clone https://github.com/clojure/clojurescript.git /tmp/clojurescript
# 2) Clojure repository cloned under this current directory:
#    git clone https://github.com/clojure/clojure.git

- [[/tmp/clojurescript/][ClojureScript]],
- [[clj:src/clj/clojure/core.clj::(defn str][clojure.core/str]].

***** org keyword ~OSTA_LINK~
****** description

In my org files, I often use links to directories which are clones of
repositories.  If those repositories are hosted on Github for
instance, they can be reached with web urls.

With ~osta~ you can declare such mappings between directories and
web urls with the org keyword ~OSTA_LINK~ respecting the following
syntax:

: #+OSTA_LINK: /path/to/example/ --> https://example.com

Once you've declared those mappings, ~osta~, when exporting, will
replace the links to the directories by their mapped web urls.

Note that mapped links declared with org keyword ~OSTA_LINK~ have
prevalence over any other file links.

****** example

Assuming, you have a cloned of ClojureScript repository
(https://github.com/clojure/clojurescript) under the directory
~/tmp/clojurescript/~.

You can declare a mapping between the repository on your machine
(~/tmp/clojurescript/~) and the repository on Github by adding
(anywhere) the following line to this org file:

: #+OSTA_LINK: /tmp/clojurescript/ --> https://github.com/clojure/clojurescript

With this mapping declared, the following link:

#+BEGIN_SRC text
[[/tmp/clojurescript/][ClojureScript]]
#+END_SRC

that links on your machine to the directory ~/tmp/clojurescript/~ will
be exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="https://github.com/clojure/clojurescript">ClojureScript</a>
#+END_SRC

and is rendered like this: [[/tmp/clojurescript/][ClojureScript]].

***** org keyword ~OSTA_LINK~ combined with org keyword ~LINK~
****** description

In the left part of ~#+OSTA_LINK:~ statments you can use org abbreviated
links that have been defined in ~#+LINK:~ statments.

****** example

For instance, in the following org snippets:
1) we defined the abbreviated link ~clj~ that resolves to ~./clojure/~,
2) we use it in the left part of the ~#+OSTA_LINK:~ statements and,
3) we use it in a link.

#+BEGIN_SRC text
,#+LINK: clj ./clojure/
,#+OSTA_LINK: clj:src/clj/clojure/core.clj::(defn str --> https://github.com/clojure/clojure/blob/abe19832c0294fec4c9c55430c9262c4b6d2f8b1/src/clj/clojure/core.clj#L546

[[clj:src/clj/clojure/core.clj::(defn str][clojure.core/str]]
#+END_SRC

When you use the command ~org-open-at-point~ (bound to ~C-c C-o~) on the
previous link, you "jump" (inside emacs) to the definition of the
function ~str~ defined in the file ~./clojure/src/clj/clojure/core.clj~
(assuming, you have a cloned of Clojure repository
https://github.com/clojure/clojure under the directory ~./clojure/~).

When you export the previous link with ~osta~, you get the following
anchor tag:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="https://github.com/clojure/clojure/blob/abe19832c0294fec4c9c55430c9262c4b6d2f8b1/src/clj/clojure/core.clj#L546">clojure.core/str</a>
#+END_SRC

that points:

1) to the definition of the function ~str~,
2) on line ~546~ for the commit ~abe19832c0294fec4c9c55430c9262c4b6d2f8b1~,
3) in the file ~src/clj/clojure/core.clj~,
4) on Github,
5) in the repository: ~https://github.com/clojure/clojure~,

and is rendered like this: [[clj:src/clj/clojure/core.clj::(defn str][clojure.core/str]].

**** links to local files in the ~public~ directory
:PROPERTIES:
:CUSTOM_ID: /doc/links/#local-files-in-public-dir
:END:

- [[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]]

***** description

One might want to generate at build time files that are going to be
available in the ~public~ (root of the website by default) directory.
Those files not need to be ~osta~ pages (that means not need to have
dedicated entries in this org file).

Those files, that are not ~osta~ pages, can't be linked in this
org file with ~custom-id~ links (because those links would be broken
inside emacs, and we don't want that).

For those files, that will end up in the ~public~ directory after the
build, we can use local file links.  They will be exported removing
the ~./public~ part of the path making them accessible via web url.

It's convenient, because this way, after the build of the website,
those links stop being broken in this org file.

***** example

For instance, assuming the build of the website produces the markdown
file ~./public/doc/plain-list-and-item.md~ that is a markdown
version of the page ~/doc/plain-list-and-item/~, we can link
to that markdown file in this org file as follow:

#+BEGIN_SRC text
[[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]]
#+END_SRC

This previous link is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item.md">page about plain-list in markdown format</a>
#+END_SRC

and is rendered like this: [[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]].

***** root directory ~public~ can be modify with org keyword ~OSTA_ROOT~

The root directory of the website is defined in the ~:option-alist~ of
~osta~ org export backend with the keyword ~:osta-root~.

By default, it is set to ~public~, but you can change it using the org
keyword ~OSTA_ROOT~ in this org file.

For instance, you can set the default root directory of the website to
the directory ~build~ adding this line ~#+OSTA_ROOT: build~ at the top of
this org file.

If you do so, the following link:

#+BEGIN_SRC text
#+OSTA_ROOT: build
# ...
[[./build/doc/plain-list-and-item.md][page about plain-list in markdown format]]
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item.md">page about plain-list in markdown format</a>
#+END_SRC

and is rendered like this: [[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]].

**** links to local files in the ~assets~ directory
:PROPERTIES:
:CUSTOM_ID: /doc/links/#local-files-in-assets-dir
:END:

- [[./assets/images/osta.png][osta image]]

***** description

Files in the directory ~assets~ (by default) are copied into the
directory ~public~ (root of the website by default) when the website is
built.

All file links pointing to files in the ~assets~ directory, once the
website has been built, will point to files in the directory ~public~.
The links will be exported removing the ~./assets~ part of the path
making them accessible via web url.

It's convenient, because this way:
1) we can "clean" the ~public~ directory whenever we need it and,
2) local file links in this org file are never broken.

***** example

For instance the following link:

#+BEGIN_SRC text
[[./assets/images/osta.png][osta image]]
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/images/osta.png">osta image</a>
#+END_SRC

and is rendered like this: [[./assets/images/osta.png][osta image]].

***** assets directory ~assets~ can be modify with org keyword ~OSTA_ASSETS~

The directory where the assets go (~css~, ~js~, ~images~) is define in the
~:option-alist~ of ~osta~ org export backend with the keyword
~:osta-assets~.

By default, it is set to ~assets~, but you can change it using the org
keyword ~OSTA_ASSETS~ in this org file.

For instance, you can set the assets directory to the directory
~resources~ adding this line ~#+OSTA_ASSETS: resources~ at the top of this
org file.

If you do so, the following link:

#+BEGIN_SRC text
#+OSTA_ASSETS: resources
# ...
[[./resources/images/osta.png][osta image]]
#+END_SRC

is exported as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<a href="/images/osta.png">osta image</a>
#+END_SRC

and is rendered like this: [[./assets/images/osta.png][osta image]].

**** local file links that raise an error (~osta-link-broken~)
***** description

# uncomment the last line of this comment (unresolved file link),
# narrow the buffer to this subsection, and export the narrowed
# buffer with osta.
# --> This must raise an error because:
#     1) the directory /tmp/ has no mapping to an web url
#        declared with org keyword OSTA_LINK,
#     2) neither is a local relative file in the root
#        directory ./public/,
#     3) neither is a local relative file in the assets
#        directory ./assets/.
# --> [[/tmp/]]

Any file link that is not one of the following links:

1) [[#/doc/links/#local-files-mapped-to-web-urls][link to a local file mapped to web url]],
2) [[#/doc/links/#local-files-in-public-dir][link to a local file in the public directory]],
3) [[#/doc/links/#local-files-in-assets-dir][link to a local file in the assets directory]],

raises an ~osta-link-broken~ error when ~osta~ try to export it.

***** example

Assuming we haven't declared an ~OSTA_LINK~ mapping between the
directory ~/tmp/~ and any web url, the org file link:

#+BEGIN_SRC text
[[/tmp/]]
#+END_SRC

that is not in the ~public~ nor in the ~assets~ directory will raise (when
we try to export the link with ~osta~) an error like the following:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC text
(osta-link-broken "/tmp/" "goto-char: 26308")
#+END_SRC

** plain-list and item
:PROPERTIES:
:OSTA_PAGE: t
:CUSTOM_ID: /doc/plain-list-and-item/
:END:

Only /unordered/ and /ordered/ lists are supported.

*** unordered lists
:PROPERTIES:
:CUSTOM_ID: /doc/plain-list-and-item/#unordered-lists
:END:

The following org snippet (unordered list):

#+BEGIN_SRC text
- a thing,
- another thing,
- and the last one.
#+END_SRC

is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<ul>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ul>
#+END_SRC

and is rendered like this:

- a thing,
- another thing,
- and the last one.

*** ordered list

The following org snippet (unordered list):

#+BEGIN_SRC text
1) first,
2) second,
3) third.
#+END_SRC

is exported by ~osta~ as follow:

#+ATTR_OSTA_RESULTS:
#+BEGIN_SRC html
<ol>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ol>
#+END_SRC

and is rendered like this:

1) first,
2) second,
3) third.
